%% This is file `elsarticle-template-1-num.tex',
%%
%% Copyright 2009 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for Elsevier's document class `elsarticle'
%% with numbered style bibliographic references
%%
%% $Id: elsarticle-template-1-num.tex 149 2009-10-08 05:01:15Z rishi $
%% $URL: http://lenova.river-valley.com/svn/elsbst/trunk/elsarticle-template-1-num.tex $
%%
\documentclass[preprint,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
%% \usepackage{graphics}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
%% \usepackage{lineno}

\usepackage[normalem]{ulem} % for \sout


%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%
%% \biboptions{comma,round}

% \biboptions{}


\journal{Science of Computer Programming}
\input {utils}
\graphicspath{{images/}}

\newcommand{\ra}{$\rightarrow$}
\newcommand{\chg}[2]{\textcolor{red}{\sout{#1}}{\ra}\textcolor{blue}{\uline{#2}}} % please change
\newcommand{\ins}[1]{\textcolor{blue}{\uline{#1}}} % please insert
\newcommand{\rewritten}{\textcolor{red}{\uline{Rewritten}\ra\space }} % please insert


\begin{document}


\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{Softwarenaut:\\ Explorative Software Architecture Recovery}


%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{<author name>}
%% \address[label1]{<address>}
%% \address[label2]{<address>}

\author{Mircea Lungu}
\address{Software Composition Group - University of Bern, Switzerland}

\author{Michele Lanza}
\address{REVEAL @ Faculty of Informatics - University of Lugano, Switzerland}


\begin{abstract}
When the initial architecture of a system has eroded the only solution is architecture recovery. However, when the system under analysis is large, the user must use dedicated tools to support the recovery process. In this article we present Softwarenaut -- a tool which supports architecture recovery through interactive exploration and visualization. The tool provides overview and detailed perspectives which support the architecture recovery process as well as powerful navigation primitives and filtering mechanisms that allow managing the complexity of large software systems. The recovered architectural views can be shared between users through a Global Architectural View Repository allowing collaborative architecture recovery.
\end{abstract}

\begin{keyword}
Architecture Recovery \sep Visualization \sep Reverse Engineering
\end{keyword}

\end{frontmatter}

%%
%% Start line numbering here if you want
%%

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction} \label{sec:Introduction}
%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%

No software system is an island. Instead a system exists and functions in an environment, and when the environment changes the system must change too or become obsolete\cite{lehman-softev}. As a result, maintaining a software system implies a continuous effort to keep it up to date with the unanticipated changes in its environment. Having a clear and up to date understanding of the architecture of a system is critical for its maintenance and evolution \cite{Duca09c, pollet-sar}.

As a system evolves, the architecture erodes \cite{perry-foundations} and an architectural mismatch appears between the {\em as-defined} and {\em as-is} architecture \cite{garlan-mismatch}. One accompanying property of this continuous drift between the actual architecture and the defined architecture of the system is an increasing brittleness of the system \cite{perry-foundations}. The main reason for architectural erosion and drift is widespread lack of programming language support for expressing the architecture, as well as the lack of tools that associate architectural decisions with the source code. The problem is an instance of the documentation problem: it is well known that the documentation of the system becomes quickly obsolete unless developers dedicate conscientious effort towards keeping it up to date \cite{riva-report}.

When the drift and erosion have brought the system architecture too far from the initial state, the solution is to recover the architecture of the system from the source code. Jazayeri defined architecture recovery as ``{\em the techniques and processes used to uncover a system's architecture from available information}'' \cite{jaza-archevo}. 

In the case of large software systems the architecture is specified through multiple architectural views that correspond to a set of given {\em architectural viewpoints}. An architectural viewpoint is a pattern or template from which to develop individual views by establishing the purposes and audience for a view and the techniques for its creation and analysis. Even if different authors propose different viewpoints \cite{bass-architecture, kruchten-4plus, hof-apparch} the consensus is that multiple viewpoints are necessary for capturing all the various facets of a system.

Usually, architecture recovery tools focus on recovering module views through visualization and interaction \cite{murphy-reflexion, muller-rigi, storey-shrimp}. While some steps of the process can be automated (e.g., fact extraction, view generation), no tool works completely without human intervention. In some cases the user has to group related artifacts together based on their similarity of purpose \cite{muller-rigi}. In other cases the user has to compare the architecture as-extracted with the architecture as-predicted \cite{murphy-reflexion} or the user has to decide which exploration paths to follow \cite{storey-shrimp}.

We present Softwarenaut \cite{lungu-relevo, lungu-packages} - the architecture recovery tool that we have developed. Softwarenaut provides interactive exploration mechanisms that support the semi-automated discovery of architectural views of any object-oriented system and allows the sharing of such architectural views. 

{
%\footnotesize 
\paragraph{Structure of the article} \sref{over} is an overview of Softwarenaut. The following two sections discuss two important phases in the workflow of any architecture recovery tool: information aggregation (\sref{org}) and interactive exploration (\sref{interact}). In \sref{evol} we detail on the way in which Softwarenaut provides support for evolutionary analysis. In \sref{views} we show how the sharing architectural views can enable collaboration. In \sref{archi} we discuss architectural considerations and in \sref{disc} we discuss the tool-building experience. In \sref{rel} we present related work and in \sref{conc} we conclude and outline future directions.

}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Softwarenaut in a Nutshell} \label{sec:over}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Softwarenaut is an architecture recovery tool based on interactive exploration, with the goal of discovering architecturally relevant views \cite{lungu-packages}.

The main interaction approach in Softwarenaut is to let the user navigate from an automatically aggregated high-level view on the system downwards, also known as {\em top-down exploration}.


\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{SnautWorkflow}
\caption{Softwarenaut supports an extract-abstract-view workflow model}
\flabel{flow}
\end{center}
\end{figure}

Like other architecture recovery tools \cite{pollet-sar}, Softwarenaut conforms to a classical extract-abstract-view architecture. \fref{flow} presents the three main steps of this architecture. In each of the three steps the tool offers state of the art features:

\begin{itemize}
\item {\em Fact Extraction.} The tool can analyze any object-oriented system through a system of pluggable fact extractors which export information to a well-known meta-model. 
\item {\em Information Aggregation.} The tool takes into account the hierarchical decomposition of a system as a basis for aggregating artifacts and relationships. In the case of a missing hierarchical decomposition the tool can automatically generate one.
\item {\em Interactive Visualization and Exploration.} The tool allows for an overview, zoom and filter, and details on demand approach. The tool provides a powerful set of filtering mechanisms. The recovered architectural views can be shared between users, and reused by other tools.
\end{itemize}
%, {\em fact extraction}, {\em information aggregation}, and {\em interactive visualization and exploration}.

The article continues with detailing the second and third step, the first one being discussed later in the section on architectural concerns regarding the tool.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Information Abstraction} \label{sec:org}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Aggregating horizontal relationships between software artifacts along the containment relationships is the fundamental technique that enables abstraction in Softwarenaut. 

\fref{dep-agg} exemplifies the aggregation of low-level relationships between methods and classes along the containment hierarchy of a Java system. 
The figure contains for example the following two explicit low-level dependencies: the method calls between \cod{mX} and respectively \cod{mY} and \cod{mZ}. These explicit dependencies propagate as implicit relationships vertically along the containment relationships (e.g. \cod{mX $\rightarrow$ CA2 $\rightarrow$ A2  $\rightarrow$A}, where $\rightarrow$ represents containment relationships). The highest level implicit relationship is the one between A and B. 

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.9\linewidth]{DependencyAggregation}
\caption{The aggregation of explicit dependencies into implicit ones along the containment relationships between methods, classes, and packages in a Java system}
\flabel{dep-agg}
\end{center}
\end{figure}

\rewritten 

Aggregating the relationships across the vertical hierarchy has an $O(n^2)$ order of complexity \cite{buchsbaum-hierarchicalgraphs}. This means that for non-trivial systems, the on-the-fly computation of the dependencies can make interactive analysis sluggish. To allow interactivity one must pre-compute the dependencies between the nodes in the hierarchy. The data structure that allows keeping track of the pre-computed dependencies is a {\em hierarchical graph}. 


%A data structure that allows for this is the hierarchical graph \cite{buchsbaum-hierarchicalgraphs}. In our case, the DPMHigraph\footnote{DPM stands for Detail Project Model. For the importance of the concept see  \cite{lungu-thesis}} is a data structure formed by taking the graph of basic artefacts and relationships between them and aggregating them along the containment hierarchy of the system. 

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{HigraphModel}
\caption{The {\em hierarchical graph} implementation in Softwarenaut.}
\flabel{hmodel}
\end{center}
\end{figure}

\fref{hmodel} presents our implementation of a hierarchical graph model in Softwarenaut.
The diagram shows that a Hierarchical Graph contains two types of entities: 

\begin{description}
\item {\bf Tree Nodes.} They are the wrappers of ModelEntities --- artifacts in a software system which can be organized hierarchically in a containment tree. The diagram shows that the tree is implemented using a Composite design pattern. The objects that the leaves are wrapping depend on the type of analysis and available data (in some cases they are classes, and in some others they are methods and instance variables). The composite entities are higher-level entities which are either declared in the programming language (such as namespaces and packages) or are obtained as a result of analysis (such as clusters resulting from the hierarchical clustering of the leaves).
\item {\bf Relationships.} There are two types of relationships: explicit and implicit. The Explicit Relationships are the ones that have been extracted from the static analysis of the code or the dynamic analysis of the running system. Most of the times the explicit relationships exist between the leaves of the tree (e.g. invocations between methods) but this is not necessarily so (e.g. the inheritance relations between classes in a tree which contains both methods and classes). The Explicit Relationships are wrapping actual relationships that are part of the model and which are subclasses of Model Relationship.

The Implicit Relationships are derived from the Explicit Relationships by aggregating them along the containment tree. %The result is that between any two high-level components there is an Implicit Relationship.

\end{description}

The static analysis of object-oriented system has limitations. One of them is that some dependencies can not be unequivocally resolved. In the presence of a method that is defined in a base class and overriden in the subclasses it is impossible to know just by static analysis to which of the classes a method call will directed. The decision will be taken by the model extractor. Whatever that decision, the relationships that are extracted by the extractor will be modelled in the hierarchical graph with Explicit Relationships.


%\item {\em Explicit Relationships}. These are the relations between two entities as they exist in the code. Softwarenaut models method invocations, class inheritance, and field access. Although the three types of relationship are the ones supported by default in Softwarenaut, other types of relationships can be supported by subclassing the ExplicitRelatinoship class and providing adequate fact extractors.

%\item {\em Implicit Relationships}. The model admits relationships between any abstract entities. However, in software systems explicit relationships usually exist only between the leaf entities. Therefore, the relations between the composite entities must be inferred bottom-up from the relations existing between the leafs. The result is that between any two high-level components, we have a relation that represents a collection of all the relations between the leaf components aggregated in them.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Interactive Exploration} \label {sec:interact}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The UI of Softwarenaut contains three linked complementary visual perspectives that present information about a system during the exploration. \fref{sos} presents Softwarenaut visualizing an architectural view of itself. The linked complementary perspectives support the ``overview first, zoom and filter, and details on demand'' principle of information visualization \cite{shneid-eyes}. 



\begin{figure}[ht]
\begin{center}
\includegraphics[width=\linewidth]{SnautOnSnaut.pdf}
\caption{Linked views present complementary perspectives on a software system }
\flabel{sos}
\end{center}
\end{figure}

The three complementary views that the tool supports are the architectural, the detail, and the overview views:

\begin{description}

\item The {\em Architectural View} is Softwarenaut's main view. It is a graph-based representation of modules and their dependencies. The nodes in the graph represent modules and the edges represent the dependencies between the modules. Each dependency edge is an aggregation of low-level dependencies between the two associated modules. To represent the nodes and edges here we use Lanza's polymetric approach \cite{lanza-pv, lanza-oomp}. 

\item The {\em Detail} panel presents details for an entity selected in the Exploration panel. The goal is to supplement details of the element selected in the exploration panel. The detail panel implements the ``details-on-demand'' part of Shneiderman's visualization mantra \cite{shneid-eyes}.

\item The {\em Overview} panel presents the entire hierarchy of a system and highlights the modules that are visible in the exploration panel. The Overview panel presents a horizontal slice through a system \cite{wong-thesis}, offering an orientation aid which is critical for successful navigation \cite{storey-awareness}.

\end{description}

In this section we detail the interactive techniques that support the exploration process in Softwarenaut: navigation (\ref{sec:navi}), details-on-demand (\ref{sec:dod}), rule-based filtering (\ref{sec:filtering}) and first-class views and collaboration (\ref{sec:views}).  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Navigation} \slab{navi}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The dominant exploration mechanism of Softwarenaut is navigation along the vertical decomposition of the system. One starts with a very high-level abstracted view of a system and continuously refines by using exploration operations \cite{robertson-conetrees}. At any given moment the set of visible nodes in the exploration view with which the user interacts constitutes the working set (WS). Initially the working set contains very few high-level nodes. As the user explores the system he transforms the working set by performing exploration operations on it and thus changes the contents of the view in the exploration view.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\linewidth]{SnautSequence}
\caption{The expand and collapse complementary operations that allow vertical navigation in the hierarchical graph}
\label{}
\end{center}
\end{figure}

The exploration operations supported by Softwarenaut are:

\begin{description}

\item {\em Expand}. The expand operation applied to a node N of the hierarchical graph (HG) in the working set (WS) replaces the node in the working set with nodes that represent its children. 

We define the operation formally as follows: 

$ Expand_{N,HG} (WS) = WS - N + Children (N, HG)$, 

where $Children(N,HG)$ is a function which returns the children of node $N$ in hierarchical graph $HG$ and ``+'' and ``-'' represent respectively set union and set subtraction.

\item {\em Collapse}. The collapse operation applied to a module in a working set removes the module and all its siblings from the view and replaces them with their parent module. 

We define the operation as follows:

$ Collapse_{N,HG} (WS) = WS - N - Siblings (N, HG) + Parent (N, HG)$

where $Siblings(N, HG)$ is a function which returns the nodes that have the same parent with $N$ in the hierarchical graph denoted with $HG$, and $parent(N,HG)$ is a function which returns the parent of node $N$ in hierarchical graph $HG$. 

\item {\em Filter}. The filter operation applied to a node removes that node from the working set. 

We define the operation as follows:

$ Filter_{N,HG} (WS) = WS - N$

\item {\em Group}. The group operation applied to several modules in a working set removes the modules from the set and adds instead a unique new node representing the entire group. 

We define the group operation as follows: 

$ Group_{N_{i},HG} = WS - N_i + NewGroupNode $

where $N_i$ is the set of nodes the user wants to group.

\end{description}

As the user refines the view, and climbs down in the hierarchy of the system, he brings more and more elements into the view. He can use the Filter and Group operations on explicit sets of nodes to decrease the number of nodes displayed on screen and therefore cope with the complexity of large graphs. One type of modules that benefit the user when filtered out are the {\em omnipresent modules} which contribute little to the understanding of the architecture of the system, and heavily clutter the view \cite{mitchell-bunch}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection {Details-on-Demand} \slab{dod}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The elements of every architectural view in Softwarenaut are nodes that represent modules and edges that represent relationships between them. For the user to be confident that he {\em understands} such a view he needs to understand the role of every node and the meaning of every edge. Metaphorically, if the view were a phrase, the nodes would be the nouns and the edges would be the verbs. One can understand the message only when he has understood all the nouns and the verbs.

The Detail panel of Softwarenaut is one of the ways in which one can understand the individual nodes and edges in an architectural view; it presents different views depending on the selected element in the exploration view. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection {Detail Views for Modules}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%TODO: Quickly implement an evolutionary detail view for modules. IT is too lame to have Method List in there!!!

The detail views for modules present various details of a module under focus. Softwarenaut provides a variated set of detail views for nodes that allow understanding the module under focus. Two examples of such views are: 

\begin{itemize}
\item The {\em Class List} detail view lists all the classes contained in a module and its submodules together. For these classes the user can select various software metrics. The left column of \fref{detail-views} presents the {\em Class Metrics} detail view on some of the classes in the Softwarenaut system itself together with the WLOC metric.
\item The {\em Method List} is similar to the Class List only that it presents methods and corresponding metrics. 

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection {Detail Views for Relationships}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The detail views for relationships present information about the selected relationships. Since understanding the relationships is critical for understanding the view, Softwarenaut provides a broad set of detail views for relationships which cover both structural and evolutionary aspects of the relationships \cite{lungu-cutedge, lungu-relevo}. Two examples of such interactive detail views are:



\begin{description}
\item The {\em Invoked Artefacts} view lists all the artefacts invoked by the selected high-level dependency. The right column of \fref{detail-views} presents such a view. The tree has on its first level the invoked classes, on the second level invoked methods, and on the third level call sites. The user can navigate to any of the presented code artifacts from this view.
\item The {\em Evolution Filmstrip} view presents the evolution of the given relationship in all the versions of the system which are available for analysis. The two modules and the associated relationship are represented in every analyzed version. Section \ref{sec:evol} presents more details about the Evolution Filmstrip while discussing evolutionary aspects of the tool.
%\fref{dedge} shows a relationship which changed dramatically during the six versions of the system under analysis. 
\end{description}

\begin{figure}[t!]
\begin{center}
\includegraphics[width=0.8\linewidth]{DetailsForEdgesAndNodes}
\caption{Detail Views: 
Class Metrics (left)
and 
Invoked Artifacts (right)} 
\flabel{detail-views}
\end{center}
\end{figure}



%\newpage
\subsection {Rule-Based Filtering}
\slab{filtering}

In the previous section we have introduced the Filter operation which works on explicit sets of nodes. Most software architecture recovery tools offer such a filter operation \cite{aracic-filtering}. Softwarenaut implements several categories of advanced {\em rule-based filters} for nodes and edges. Softwarenaut supports two types of basic filters: 

\begin{enumerate}

\item {\em Low-level filters} act on the hierarchical graph itself. They remove from the hierarchical graph the low-level elements that match a given condition, e.g., all the invocation relationships that go to polymorphic classes.

\item {\em High-level filters} act on the high-level elements and relationships between them in the working set, e.g., hiding all the high-level dependencies that abstract few low-level dependencies.

\end{enumerate}

During exploration, the user interacts mostly with the High-level filters. There are two types of filters that apply to both artifacts and relationships: 

\begin{enumerate}
\item {\em Metric-based filters} for entities and relationships are defined with respect to the metrics computed for artifacts. For example filtering out {\em the weak dependencies} or {\em the small modules} in a view.
\item {\em Type-based filters} for entities and relationships are defined with respect to the type of the artifacts. For example showing {\em only inheritance relationships} or hiding {\em all the classes} from a view.
\end{enumerate}

Softwarenaut also implements advanced filters for relationships:

\begin{itemize}

\item {\em Evolutionary filters} are defined based on the historical evolution of an inter-module relationship in the system\footnote{Evolution-based filters require models of multiple versions of a system loaded}. For example showing only the {\em relationships that existed in all the versions of a system} or hiding all the {\em unstable relationships} \cite{lungu-relevo}.

\item {\em Directional filters} are defined based on the direction of the relationship between two modules. For example, filtering out the unidirectional relationships from an architectural view is useful for highlighting the modules that have mutual dependencies between themselves. 

\end{itemize}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\linewidth]{SnautFilteringPanel}
\caption{The UI for applying relationship filters in Softwarenaut}
\flabel{filpan}
\end{center}
\end{figure}

\fref{filpan} presents the relation filtering panel as implemented in Softwarenaut. Several filters can be combined to obtain more powerful ones with either the ``and'' or the ``or'' operator. The elements that match the filter can be either ``shown'' or ``hidden''. The user can define new filters by writing simple scripts in Smalltalk. The system is fully reflective, and as soon as a new filter is defined, it will immediately appear in the list of available filters.

\subsection {History Operations} Softwarenaut keeps a history of the exploration and filtering actions to support undo and redo operations. This is a requirement for information exploration tools \cite{shneid-eyes} that few other architecture recovery tools implement.

%\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Evolutionary Analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slab{evol}

Softwarenaut can take evolutionary information into account to provide better detail views and filters.

To support multi-version analysis Softwarenaut requires that models of multiple versions of the system under analysis be available. \fref{fig:mva} shows that a system history in Softwarenaut is composed of a list of hierarchical graphs, one for each analyzed version. This approach is conceptually the same as the one of G{\^i}rba \cite{girba-thesis}. One limitation of such an approach is that the number of versions that can be analyzed can not be too large. As a result one needs a strategy for selecting the versions that compose the history.

To allow monitoring the evolution of the individual elements through multiple versions one needs to link the corresponding elements in the different versions. Although more complicated approaches are available, in our case we perform a name-based matching of the entities.

\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{images/MultiVersionAnalysis}
\caption{In multi-version analysis each version considered has a corresponding hierarchical graph}
\flabel{fig:mva}
\end{center}
\end{figure}

The two applications of multi-version analysis in Softwarenaut are detail views and filters. In the following sections we will detail each on in turn.

\newpage
\subsection {Evolutionary Detail Views}
One of the applications of multi-version analysis is the {\em Relationship Evolution Filmstrip} \cite{lungu-relevo}. The Filmstrip is a detail view which presents the evolution of a given relationship between two modules over the time. %The view can be useful for understanding a relationship based on its history.

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.82\linewidth]{images/Filmstrip}
\caption{The Relationship Evolution Filmstrip presents the evolution of a given relationship through the multiple versions of the system available for analysis}
\flabel{fig:evolstrip}
\end{center}
\end{figure}


\fref{fig:evolstrip} presents two examples of relationship evolution filmstrips from two of our case-studies: Azureus and ArgoUML. In the film strip, the arrows between the modules represent implicit dependencies of different types (the invocation dependencies are represented in black and the inheritance dependencies are represented in red). The width of the dependency arrows is proportional to the number of low-level dependencies abstracted in the corresponding implicit dependency \cite{lungu-relevo}. The representation of the width of the dependencies provides insight into the quantitative dynamics of the inter-module relationship.

In the first case the figure shows that the relationships between the two modules evolved heavily during the evolution. In the second case we see that the relationship is recent and weak: it shows that the kernel depends on the internationalization ({\em i18n}) module. 



\subsection {Evolutionary Filters}

Filters for relationships and modules are a powerful mechanism for coping with the large graphs that some systems entail. They allow displaying only those elements in an architectural view that are important for a given task and this focusing the analysis. 
%TODO: have a reference here!

Evolutionary filters for both relationships and entities can be classified in two main categories:

\begin{description}
\item {\em Age-based} filters take into account the number of versions in which the relationships or modules existed in the system. {\em Lifetime relationships} have existed in all the versions of the system, {\em Newborn relationship} have appeared only in the last analyzed version \cite{lungu-relevo}, {\em Historical modules} have existed since the first analyzed versions of the system.
\item {\em Dynamics-based} filters take into account the dynamics of the relationships and modules across versions. {\em Stable relationships} do not change much during the evolution of the system, {\em Instable relationships} changed much during the history of the system.
\end{description}

Evolutionary filters assume that not all the entities are equally relevant for the task at hand. Different types of evolutionary filters support different goals of analysis. Two such goals and the corresponding filters are:

\begin{enumerate}
\item {\em Architecture Recovery.} When recovering the architecture of a system one needs to discover first the main components of the system. A filter like {\em lifetime relationships} is relevant since the relationships that existed in the system since the first versions are more likely to be part of the architectural backbone of the system.
%TODO Reference.
\item {\em Quality Assessment.} When assessing the quality of an architecture the goal is to find the problems, the irregularities. In this context filters like {\em newborn relationships} are of use since they allow focussing on new relationships that were were not validated by time which might be the result of changes performed by new developers that are unaware of the architecture of the system. 
%Reference
\end{enumerate}

\fref{lvr} presents two views on the same modules that are also present in \fref{filpan} but with age-based filters activated. 
The left side presents only the {\em lifetime relationships}: 21 relationships that existed between the displayed modules in all the versions of the system. The right side presents only the {\em newborn relationships}: 36 relationships introduced in the system in the latest version. 

The usefulness of the filters is hinted by the fact that in both the views, the number of relationships is very low compared with the total number of relationships that are present in the last version of the system; ergo, both types of filters function as powerful information reductors.

\begin{figure}
\begin{center}
\includegraphics[width=\linewidth]{Architecture-LifetimeVsRecent}
\caption{The left part of the figure shows the {\em lifetime relationships} while the right part of the figure presents the {\em newborn relationships} in the Azureus case study}
\flabel{lvr}
\end{center}
\end{figure}



\newpage
\section {First-Class Views and Collaboration}
\slab{views}


Traditionally software analysis tools were designed with a {\em throw-away} attitude  in mind. One was supposed to start the analysis, arrive at some results, and then conclude the analysis. In Softwarenaut we want to allow the interruption and continuation of the analysis, and the reuse of the results of the analysis between sessions. Moreover, traditional software analysis never reuse the information that one user has gained about a certain version of the system. This is wrong since once published a version never changes and therefore the results of one analysis can inform further analyses. 
In Softwarenaut these two problems are addressed with the help of {\em first-class views} and the concept of a {\em Global View Repository}, a mechanism for publishing and discovering existing views.


\subsection {First-Class Views}
The designers of a system use multiple diagrams for the specification of the architecture of a system. In the same way, during architecture recovery they need to recover multiple views to capture various aspects of the structure of the system. 

Views are first-class entities in Softwarenaut: one can save and restore any view during the exploration. During an exploration session, each time the analyst encounters a view which presents a relevant perspective on the system he can save it for later reference. The result of a Softwarenaut analysis is therefore a {\em set of architectural views}.

%This this allows for a {\em divide et impera} approach to architecture recovery and representation: 
The view persistence mechanism can be used also as a way of conquering the complexity of top-down exploration. When the architectural view under analysis becomes too complex, the user can save it and then explore different sub-parts of it. This is addressed partially in other tools by the use of semantic zooming techniques \cite{storey-shrimp}. 

In Softwarenaut a {\em view} contains the following information: 
\begin{itemize}
\item a name and description,
\item the name and version of the system under analysis
\item the current working set with the positions of all the nodes in it,
\item the active artifact and relationship filters (both explicit and rule based), 
\item the name of the creator of the view
\end{itemize}

The model of the system is not saved together with the view. We assume that model construction is deterministic and the name and version of the system will suffice for model reconstruction at a later time \footnote{This requires nevertheless a way of uniquely identifying the entities in the view. In our case, for each of the entities in the working set we save the fully scoped name}.



% Moreover, in most of the cases the views are reused locally.


%The filters are predefined. In the future we plan to support user-defined filters and their publication together with the views. 


% \fref{viops} highlights the way the user can interact with the local views. He has a set of local views that he can save, load, delete locally. 

%\newpage
% COLLABORATION
%\section {Collaboration}
%\label {sec:collab}

% We have shown that in Softwarenaut views are entities that can be saved and restored. In this section we talk about the possibility of sharing the views with other users. 

\subsection {The Sharing and Discovering of Architectural Views}
Once published, a given version of a system never changes. It makes therefore sense to make public all the analyses regarding that version, such that when other users analyze the same version or system they can benefit from the previous work and insight. In the context of architectural view recovery this means discovering architectural views that others have already defined. 


To support sharing and discovering architectural views we have created the {\em Global Architectural View Repository} (GVR) -- a public repository that indexes architectural views generated with Softwarenaut. \fref{fig:gvr} presents the idea behind the GVR. The $save(v1,Z)$ function means save view $v1$ for system $Z$. While analyzing system Z, users A and B publish views $v1$ and $v2$. When later user M analyzes the same system, he can already benefit from the previous knowledge by discovering the views that users A and B have published. 



\begin{figure}[h]
\begin{center}
\includegraphics[width=0.9\linewidth]{images/CollaborationConcept}
\caption{Architectural Views are stored in the Global View Repository. This enables collaboration through knowledge sharing and discovery}
\flabel{fig:gvr}
\end{center}
\end{figure}

The architectural views as saved in the GVR can serve as the basis for monitoring the architectural evolution of the system. After the publication of a new version of the system, Softwarenaut can automatically detect the views affected by the new changes, and present a {\em visual diff} on top of the view retrieved from the GVR between the state of the system at the moment the view was created and the latest commit.



\fref{viops} presents the current state of the UI which is responsible with the interaction with the architectural views in Sofwarenaut: 

\begin{itemize}

%\item When a user commences the analysis of a given system, Softwarenaut retrieves the list of views that are already defined for that system and/or version in the GVR.

\item The top part of the inset presents the locally stored views which the user has in the image. For each of them the user can load it, delete it, or push it to the GVR. In the inset, the buttons which have black text represent operations that can be applied on the local views.

\item The bottom part presents the views which exist for the given system in the GVR. From the global view repository he can pull views in the local repository, or if he is the creator of such a view he can delete it from the global repository too. The view sharing mechanism is the latest addition to Softwarenaut.
\end{itemize}


\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{ViewOperations}
\caption{Views are first-class entities in Softwarenaut. They can be saved, deleted locally, but also published and retrieved from the Global Architectural View Repository.}
\flabel{viops}
\end{center}
\end{figure}

The GVR is implemented as a relational database (PostgreSQL) which can be publicly accessed by instances of Softwarenaut or other tools. %In the future we plan to provide a web services interface to the GVR. 






% In such a case SPO allows navigating down to the architectural level of the individual system, where it presents architectural views which are enriched with information from the ecosystem. 


\newpage
\section {Architectural Considerations Regarding Softwarenaut}
\slab{archi}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection {Fact Extraction and Modelling} \label{sec:facts}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

At the lowest level, Softwarenaut models a system using the Core of the FAMIX meta-model \cite{tichelaar-thesis}, a language independent meta-model that describes the static structure of object-oriented software systems. 
Given that the FAMIX meta-model is language independent, Softwarenaut can analyze any system written in an object-oriented language. This requires fact extractors that analyze the source code and build the intermediary FAMIX model. For this we use various third-party tools like McC \cite{pepi-mcc} or inFusion\footnote{See \url{http://www.intooitus.com/inFusion}, verified Jan 25 2011.}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%{\bf Entities and relationships in FAMIX.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
FAMIX represents both artifacts and relationships as first-class entities. The main artifacts are namespaces, packages, classes, attributes, methods, fields. The main relationships between these entities are method invocations, variable accesses, class inheritances, and package include relationships \cite{tichelaar-thesis}.

A class of relationships which have a special importance in Softwarenaut are the containment relationships which organize a software system in a vertical hierarchy: classes contain methods, modules contain classes, systems contain modules. This containment mechanism is a powerful way of coping with the complexity of large software systems.

At an architectural level, different languages provide different mechanisms for the hierarchical organization of the system. C/C++ developers use the directory structure to organize systems hierarchically; Java developers use the package hierarchy; Smalltalk developers use the bundles hierarchy, etc. 
When a hierarchical decomposition is not provided, we can automatically generate one using clustering techniques \cite{koschke-thesis}. We presented elsewhere an experiment with clustering the classes in a system based on natural language similarity\cite{Lung05a}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%{\bf Language Independence.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection {Integration with the Moose Analysis Platform}
We built Softwarenaut on top of the Moose Analysis Platform \cite{nier-story}. The main feature that the tool uses from Moose is the FAMIX Core meta-model for representing object-oriented systems. 
Softwarenaut makes uses of several of the views defined in Moose for the detail panel (e.g. the views that present entity metrics). Also, since behind any visual element of Softwarenaut lays a TreeNode object which wraps often a FAMIX entity (e.g. FAMIXPackage or FAMIXClass) the user can spawn other Moose analyses by selecting any of the elements of a Softwarenaut architectural view. In the same time, any tool in the Moose platform can spawn a Softwarenaut architectural analysis on any group of entities which have containment relationships and dependencies between themselves.


% The reliance of Softwarenaut on the FAMIX Core meta-model allows it to be independent of the programming language and analyze systems written in any language as long as there is a fact-extractor for that particular language. 



\subsection {Softwarenaut Synergies}
One of the tools that benefits from the Global View Repository is the Small Project Observatory (SPO), an ecosystem analysis tool that we have introduced elsewhere \cite{lungu-est}. SPO works at an abstraction level above the architectural level of individual systems: the {\em ecosystem abstraction level} \cite{lungu-thesis}. 

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\linewidth]{SpoArchitectural}
\caption{SPO imports architectural views saved in Softwarenaut}
\label{}
\end{center}
\end{figure}
% This type of view is dynamic, it can not become obsolete...

% The main use case in which this navigation is needed is when one wants to understand a given system in the context of the ecosystem. 

SPO needs to support navigation between the two abstraction levels to support the understanding of  the ecosystem abstraction level. When navigating from the ecosystem abstraction level down to the architectural level SPO must present architectural views of the individual systems. When they are available, the architectural views of the individual systems are obtained from the Global View Repository. SPO can therefore reuse architectural information generated with Softwarenaut.



% \newpage
% DISC
\section {Tool-Building Considerations}
\label {sec:disc}

Softwarenaut served as the prototype for many of the research ideas we had during the PhD of the first author. We have integrated the tool with others \cite{lungu-clust, lungu-scico, nier-story} and we provided a framework in which master projects can be developed \cite{boeckmann-mars}. We have also used the tool several times to perform reverse engineering in consulting projects.

The tool was the basis for a number of research papers: 
\begin{itemize}
\item {\em Exploring Inter-Module Relationships in Software Systems} \cite{lungu-relevo}: The article presents a taxonomy of inter-module dependencies in software systems based on their evolution patterns.
\item {\em Interactive Exploration of Semantic Clusters} \cite{lungu-clust}: The article proposes a technique for visualizing dendrograms of software systems using an exploration approach.
\item {\em Cutting Edge Visualization in Software} \cite{lungu-cutedge}: The short article argues for the importance of providing detail views that allow one to understand dependencies in software.
\end{itemize}

%\cite{lungu-cutedge, lungu-clust, lungu-packages, lungu-relevo}. 
These papers could have not been written if it were not for the Softwarenaut which was a testbed for our ideas. 

%In the next section we present a brief discussion on evaluating the tool with students.

\subsection {Studying the Usability of the Tool}
We have often used Softwarenaut to analyze Softwarenaut itself, and this has determined several re-architecting sessions. However, all throughout the development of the tool we wanted to have a tool that was usable. One way in which we evaluated its usability was to use it in the teaching of the Software Evolution master course at the University of Lugano. 

In the second year of using the tool in the Software Evolution course we decided to have a qualitative experiment in which we asked the students to analyze a large software system they have never seen before\footnote{In this case it was ArgoUML} with the help of Softwarenaut and to produce an architectural report. Our goal in organizing the experiment was to get feedback on the usability of the tool. Although we hoped that in the process we would gain insight into its usefulness for the purpose of architecture recovery that was not the main goal of the study. 

Eight participants, seven master and one PhD student participated in the experiment. We asked them to perform the tasks presented in \tref{questions} on ArgoUML. We had them work in teams of two and asked them to provide us with a report of their findings. Our main goal was to learn about usability but we also analyzed their reports. Several of the observations we made are: 




\begin{itemize}
\item At question 1 that every group came with a different set of views on the system. We considered this to be an argument for architecture being ``{\em is in the eye of the beholder}'' just as quality is \cite{bass-architecture}. 

\item For questions 2 and 3 the opinions were divided but each group was ready to argue its position. We were satisfied to see that the tool spawned and supported argumentation and discussion, but in retrospective these two questions were too vague. In a controlled experiment one would use questions which have an unambiguous answer. 


\begin{table}[ht]
\begin{center}
\begin{tabular}{l p{0.75\linewidth}}
\# & \footnotesize{Task/Question} \\ \hline
1 & \footnotesize{Discover one or more architectural views on the system which present modules and their interactions} \\
2 & \footnotesize {Is there a subset of the modules that you consider to be at the core of the system?} \\
3 & \footnotesize {Is there a core module in the system? Why? How does it interact with the others?} \\
4 & \footnotesize {Choose one inter-module dependency in the system and analyze it. What is the reason for its existence?} \\
5 & \footnotesize {Choose one other module in the system. Analyze its interface.} \\
6 & \footnotesize {Are there cases in which two modules depend on one another that you would have not expected from the conceptual architecture?} \\
7 & \footnotesize {Overall what do you think about the structure of the system? Is it well modularized?} \\
8 & \footnotesize {You want to add support for generating code in a new language. Which module do you change? Which others are impacted? How much time do you need?} \\ \hline
\end{tabular}
\caption{The eight tasks the students had to solve in two hours.}
\label{tab:questions}
\end{center}
\end{table}

\item Questions 4, 5, and 6 were not solved by everybody. We think one reason was the insufficient training with the tool. We suspect that the main reason were the limitations of the tool at the time of the experiment. %We will discuss these limitations later. 

\item Question 7 brought agreement. All the groups that answered thought the system was well structured. We do not necessarily agree as we consider that the high-level architecture has too much coupling between the different modules. The prestige of the system might have influenced the assessment of the students. 
%Compared to other systems that we have analyzed along the time we agree that ArgoUML has a better modular structure than the average system with fewer modules and fewer inter-module dependencies. However, we 

\item Question 8. Actually these were a series of questions. To answer the first some of the students looked at the names of the modules that they encountered in Softwarenaut and correctly guessed that it would have been the {\em language} module that had to be changed. Others found the same answer in the documentation of the system. All of them used the tool to assess the modules that might be impacted. This could have not been done just by looking at the documentation.

None of the students could offer an estimation. Obviously the tool does not support this kind of analysis.
\end{itemize}

We also asked the students to fill a post-analysis questionnaire with their evaluations on the tool usability. \tref{postsurvey} presents the questions together with answers on a Lickert scale (where 1 is strongly disagree and 5 is strongly agree). It shows that most of the students found the tool easy to use and considered that the reports they generated were reliable. They estimated that they got a better understanding of the system by using the tool. 

\begin{table}[ht]
\begin{center}
\begin{tabular}{l r}
\footnotesize{Question} & Answers \\ \hline
\footnotesize{Was the tool simple to use?} & 4 5 3 4 \\
\footnotesize{Was the user interface intuitive?} & 3 3 4 3 \\
\footnotesize{Was it easy to discover dependencies between modules?} & 4 5 3 5 \\
\footnotesize{Do you think that the results generated were reliable?} & 5 4 5 4 \\
\footnotesize{Do you think ArgoUML was a good choice for a case study?} & 2 5 2 3 \\ \hline
\end{tabular}
\caption{Results of the usability questionnaire}
\label{tab:postsurvey}
\end{center}
\end{table}

We then asked the students what were the capabilities of the tool that they found the most useful during their analysis. In the order of frequency of the answers we remind: 

\begin{enumerate}
\item Showing dependencies between modules (2 times)
\item The exploration (2 times) 
\item Filters (1 times)
\item Detail views (1 times)
\end{enumerate}

Two of the students answered with {\em "all the features we have used"} and {\em "many features, you can do a lot"}. Taken into account that would increase the count for all the features listed earlier.

However, we also asked what were the features that they thought were absent in the tool. In the order of the frequency of requests we list the features here: 

\begin{enumerate}
\item User defined filters (all incoming dependencies, all outgoing dependencies, dependencies weaker than...) (3 times)
\item Arbitrary grouping of items (selected items, classes whose name matches a certain pattern, orphan classes) (3 times)
\item Undo and Redo operations (2 times)
\item Selecting edges (multiple edges, all outgoing edges) (2 times)
\item View persistence (1 times)
\end{enumerate}


We had used these results to inform our work on future versions of the tool. Many of these features are included in the tool and have been presented earlier in this article. Some are still on the backburner. One of the things that still remains to be done in the future is performing a controlled experiment to evaluate the usefulness of the tool for the purpose of architecture recovery.


\subsection {Depending on other research prototypes }
\rewritten

Depending on other research prototypes and platforms has been a benefit because we had the opportunity of using cutting edge technology, and building on the shoulders of giants, and in the same time, it made our life harder since the tools that we depended on kept moving ``under our feet'' and at times they were not maintained anymore. For example during the development of the tool the Moose framework was ported from VisualWorks Smalltalk to Pharo Smalltalk for licence reasons. The FAMIX 2.1 meta-model was declared deprecated and there is now a FAMIX 3.0 which is supported by the community. The SourcererDB has been going through an upgrade of their database and that meant that we didn't have access to their case studies for a good period of time. 

This might not be a unique experience, but it is a reminder that when building research prototypes that relies on other research prototypes one needs either to shield himself from changes upstream or to be ready to constantly adapt to the changes. We believe that the best strategy is a combination of both and that the benefits of being part of a research ecosystem outweigh the difficulties.


\subsection {Installation and Documentation}
Softwarenaut is written in the Smalltalk programming language and is released under the open source MIT Licence. The tool is available online at {\footnotesize \url{http://scg.unibe.ch/softwarenaut/}}. On the homepage of the tool there are a set of screencasts that present its various features together with other documentation, installation instructions, and instructions on how to obtain the source code. 


%\newpage
% REL
\section {Related Work}
\label {sec:rel}

There is an extended tradition of architecture recovery tools in software engineering research. Pollet et al. have presented a comprehensive overview of the work in architecture recovery in their survey article \cite{pollet-sar}. In this section we take several of the core aspects of Softwarenaut and we discuss how they are similar and how they differ from other state of the art tools.

\subsection {Exploration and Navigation} 

The first architectural visualization prototype was Rigi, a programmable reverse engineering environment which emphasizes visualization and interaction \cite{muller-revengenv}. Rigi can visualize the data as hierarchical typed graphs and provides a Tcl interpreter for manipulating the graph data. The reconstruction process is based on a bottom-up process of grouping the software elements into clusters by manually selecting the nodes and collapsing them. The approach does not scale when analyzing very large systems because the number of low-level artifacts is too large. This is why in Softwarenaut we automatically aggregating the low-level relations, and then letting the user navigate from the highest abstraction level downwards is the main interaction approach in Softwarenaut. 

One of the projects that was inspired by Rigi was the SHriMP tool \cite{storey-shrimp} and its Eclipse-based continuation \cite{lintern-creole}. SHriMP and Creole display architectural diagrams using nested graphs. Their user interface embeds source code inside the graph nodes and integrates a hypertext metaphor for following low-level dependencies with animated panning, zooming, and fisheye-view ac- tions for viewing high-level structures.
The difference between our tool and Creole is that Softwarenaut can also perform evolutionary analysis.

Pinzger proposed the ArchView approach \cite{pinzger-thesis} which provides visualizations that present the evolution of the modules in a system. His evolution analysis takes into account the annotations from the versioning system repository. However, there is no support for first-class views in ArchView and the dependencies between the modules are only based on logical coupling. 


\subsection {Filtering}
 
%Most of the architecture recovery tools support filtering \cite{aracic-filtering}. The majority of the tools allow for the explicit filtering of individual relations. 

As far as we are aware we are the only ones to propose filters based on evolutionary aspects of the relationships in the context of software exploration. However, there are two related works. The first is Wierda et al. who recover the architectural decomposition of a system through clustering; they observe that if they use for clustering only those dependencies that were in the system in both the first and the last versions, the decompositions are more precise \cite{wierda-clustering}; this observation supports our idea of considering the lifetime relationships as more relevant for the architecture than the newer relationships. 

The second related work is of Abram Hindle et al. \cite{hindle-yarn} who introduce the YARN visualization prototype which animates the evolution of dependencies between the modules of a system. The main difference between our approach and theirs is that we work on a snapshot-based model and they work on a commit-based model. Their commit-based model is advantageous since they benefit from more detailed information about the system; the disadvantage is that the animation of all the commits is time consuming. They do not support a query mechanism for visualizing only special types of relations.


\subsection {First-Class Views and Collaboration} 

The work of Storey et al. on Shrimp also allows for saving and restoring views \cite{rayside-flow}. The views are saved inside a ``Filmstrip'' which is persistent. Through the intermediation of the filmstrips the users can restore exploration sessions or even share certain views. This type of information allows people that know about each other to share information by emailing the files. The advantage of the Global View Repository is that it allows for discovering information that other users have discovered and about which the analysis is not aware. 
%(http://www.thechiselgroup.org/shrimp_manual_filmstrip)


Relevant for the collaborative reverse engineering part of our work is the Churrasco work of D’Ambros et al. \cite{dambros-churrasco}. Churrasco supports software evolution modeling, visualization and analysis through a web interface. 
Through an example scenario they show that Churrasco allows for collaborative software evolution analysis, and they attribute this to the availability on the web of the tool. The collaboration happens by annotating the various elements in the views of Churrasco. However, their tool presents a set of predefined views and they are not that much architectural views but rather design-level views. 

\rewritten
One project developed with collaboration support as the main goal is the Jazz IDE of IBM \cite{hupfer-jazz}. 
In their case they aim at supporting collaboration and awareness in small informal software development teams during forward engineering. In our case we use the Softwarenaut to support collaboration between engineers during program understanding. However, the architectural views of Softwarenaut once recovered during reverse engineering can be used to support evolutionary awareness during forward engineering. In fact, the dashboard of Jazz could benefit from integrating Softwarenaut-based architectural views which highlight system evolution.

%Jazz has several features to support awareness of team member activities in addition to screen sharing such as local history of chats that are anchored in the code providing therefore context to the discussions. The main difference between their work and ours is the goal of the project.





% CONC
\section {Conclusions and Future Work}
\label {sec:conc}

In this article we presented Softwarenaut, our tool for architecture recovery. The tool allows the recovery of architectural views of a software system through interactive exploration. The tool supports the ``overview first, zoom and filter, and details on demand'' principle of information visualization. It provides powerful filtering mechanisms and the capacity of saving and sharing architectural views. The tool was the test-bed for a variety of research projects and is still serving us in our research and consulting practice. 

There are two main research directions in which we would like to bring Softwarenaut beyond architecture recovery:

\begin{description}

\item {\em Reengineering.}
One of the tools built on top of Softwarenaut is MARS: an automated architecture refactoring recommender tool \cite{boeckmann-mars}. The tool starts from a given Softwarenaut view and checks whether move operations applied on classes can improve the architecture of the system by increasing coupling and decreasing cohesion. Preliminary results show a good recall but a low precision of the  automated refactoring recommendations generated by MARS. In the future we plan to explore more the space of reengineering operations that can be performed on an architectural view.


\item {\em Monitoring Software Evolution.}
One of our future projects is exploring ways in which the recovered views can function as a live documentation of an evolving system. The Softwarenaut views are not simple pictures but instead they code relationships between the modules of the system. A view recovered for a given version of the system can function as a reference point for presenting the future evolution of the system. After the publication of a new version of the system, Softwarenaut can automatically detect the views affected by the new changes, and visualize these changes on them.

\end{description}


\vspace{0.5cm}
\footnotesize
{\bf Acknowledgements.} We would like to thank Fabrizio Perin and Oscar Nierstrasz for feedback on earlier drafts of this paper. We would also like to thank the anonymous reviewers for their constructive feedback and the patience they had to try out the tool.



\newpage

\footnotesize
%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}

%% References
%%
%% Following citation commands can be used in the body text:
%% Usage of \cite is as follows:
%%   \cite{key}          ==>>  [#]
%%   \cite[chap. 2]{key} ==>>  [#, chap. 2]
%%   \citet{key}         ==>>  Author [#]

%% References with bibTeX database:

\bibliographystyle{model1-num-names}
\bibliography{scg,mircea}



%\
% Authors are advised to submit their bibtex database files. They are
%% requested to list a bibtex style file in the manuscript if they do
%% not want to use model1-num-names.bst.

%% References without bibTeX database:

% \begin{thebibliography}{00}

%% \bibitem must have the following form:
%%   \bibitem{key}...
%%

% \bibitem{}



\end{document}

%%
%% End of file `elsarticle-template-1-num.tex'.
