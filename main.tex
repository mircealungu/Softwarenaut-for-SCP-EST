%% This is file `elsarticle-template-1-num.tex',
%%
%% Copyright 2009 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for Elsevier's document class `elsarticle'
%% with numbered style bibliographic references
%%
%% $Id: elsarticle-template-1-num.tex 149 2009-10-08 05:01:15Z rishi $
%% $URL: http://lenova.river-valley.com/svn/elsbst/trunk/elsarticle-template-1-num.tex $
%%
\documentclass[preprint,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
%% \usepackage{graphics}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
%% \usepackage{lineno}

%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%
%% \biboptions{comma,round}

% \biboptions{}


\journal{Science of Computer Programming}
\input {utils}

\begin{document}


\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{Softwarenaut: A Tool for Collaborative Architecture Recovery}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{<author name>}
%% \address[label1]{<address>}
%% \address[label2]{<address>}

\author{Mircea Lungu}

\address{Software Composition Group\\University of Bern\\Switzerland}

\begin{abstract}
Recovering the software architecture
\end{abstract}

\begin{keyword}
Architecture Recovery \sep
Software Visualization \sep
Software Tools \sep
Reverse Engineering \sep
\end{keyword}

\end{frontmatter}

%%
%% Start line numbering here if you want
%%

% INTRO
\section{Introduction}
\label{sec:Introduction}

No software system is an island entire of itself. Instead the system exists in an environment and when the environment changes the system should change itself or become obsolete. Since the direction and speed of societal change can not be predicted, maintaining a software system implies a continuous effort to keep it up to date with the unanticipated changes in its environment. Having an clear and up to date understanding of the architecture of the system is critical to maintaining and evolving that system \cite{Duca09c}.

However, as the system evolves, the architecture erodes \cite{perry-foundations} and an architectural mismatch \cite{garlan-mismatch} appears between the as-defined and as-is architecture. One accompanying property of this continuous change and of the divergence between the system actual architecture and its initial defined architecture is an increasing brittleness of the system\cite{perry-foundations}.

The main reason for the architectural erosion and drift phenomena is widespread lack of programming language support for expressing the architecture as well as the lack of tools that associate architectural decisions with the source code. The problem is a particular case of the documentation problem: it is well known that the documentation of the system becomes quickly obsolete unless conscientious effort is put towards keeping it up to date \cite{riva-report}.

Since having a clear and up to date understanding of the architecture of the system is critical to maintaining and evolving that system \cite{pollet-sar}, in every system at some point steps need to be taken towards making explicit the architecture of the system, or recovering a system’s architecture. Jazayeri defines architecture recovery as ``{\em the techniques and processes used to uncover a system’s architecture from available information}'' \cite{jaza-archevo}.

In this work, we consider software architecture to be, as defined by Bass and Clements,: ``{\em the structure or structures of a system that consists of components, connections between them, and their properties}'' \cite{bass-architecture}. As a result, recovering the architecture means recovering the components of a system, their relationships, and their properties. 

There is consensus between the practitioners and researchers that architecture is to be expressed somehow visually and in the same time that it is too complex to be expressed in a single visual representation. As a result, architecture can only be expressed through multiple architectural views that correspond to multiple architectural viewpoints \cite{kruchten-4plus}. Each viewpoint presents the system from a given perspective (e.g. deployment, physical organization, code organization, etc.).

When the system which is subject to the architecture recovery process is a large system the process needs to be supported by semi-automated {\em architecture recovery tools}. The goal of these tools is, once the information is extracted from the source code, to support the aggregation, analysis, and filtering of this information, and eventually to present {\em architectural views} which capture the architecture of the system. 

In this article we present Softwarenaut, an architecture recovery tool that we have developed. Softwarenaut provides interactive exploration mechanisms that support the semi-automated discovery of architectural views of any system written in an object-oriented programming language and allows the sharing of such architectural views. 

\subsection*{Structure of this article.} The article is structured as follows: In Section \ref{sec:facts} we talk about the way data is imported and modelled. In Section \ref{sec:org} we show that the data such imported needs to be aggregated and abstracted along a hierarchical decomposition of the system. We continue by presenting how Softwarenaut allows the interactive exploration of the model of the system in Section \ref{sec:interact}. We discuss then the way in which the tool supports collaboration \ref{sec:collab}. % We close with a discussion in Section \ref{sec:disc} and position our work in the broader context of related work in Section \ref{sec:rel}. %Finally in Section \ref{sec:conc} we conclude and provide a quick glance on the future development directions for the tool. 



% OVERVIEW
\section {A Quick Overview}
\label{sec:over}

Softwarenaut is an architecture recovery tool in which interactive exploration is the dominant technique through which the subject software system is explored. The goal of the exploration process the discovery of multiple architecturally relevant views \cite{lungu-packages}.

Automatically aggregating the low-level relations, and then letting the user navigate from the highest abstraction level downwards is the main interaction approach in Softwarenaut. 

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{images/SnautOnSnaut}
\caption{Softwarenaut uses linked views to present multiple perspectives on a software system at once}
\flabel{sos}
\end{center}
\end{figure}

The UI of Softwarenaut is composed of three linked complementary visual perspectives that present information about the system during the exploration. \fref{sos} presents Softwarenaut visualizing an architectural view of itself. The figure illustrates the three complementary views that the tool supports:

\begin{enumerate}
\item The Exploration View. The Exploration View is the main view in Softwarenaut. It is a graph-based representation of modules and their dependencies. The modules are represented as nodes in the graph and their dependencies are represented as directed edges between the modules. Each dependency edge is an aggregation of low-level dependencies between the two associated modules. To represent the nodes and edges we use a polymetric view metaphor as introduced by Lanza \cite{lanza-pv}. 

\item The Detail View. This view presents details for the entity that is currently selected in the Exploration View. The goal of this view is to provide insight into the details of the element selected in the exploration view. This view implements the ``details-on-demand'' part of the visualization mantra of Shneiderman \cite{shneid-eyes}.

\item The Overview View. The overview view presents the entire hierarchy of the system and highlights on it the modules that are currently visible in the exploration view. The Overview view presents a horizontal slice through the system \cite{wong-thesis}. %The view is interactive: the user can navigate to the details of the elements in the view, or select elements in the detailed view and have the selection propagate to the exploration view. 
This view is significant because it offers a sense of orientation which is critical for successful navigation \cite{storey-awareness}.

\end{enumerate}


Like other architecture recovery tools \cite{pollet-sar}, Softwarenaut is organized along a classical extract-abstract-view workflow as presented in \fref{flow}.

\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{images/SnautFlow}
\caption{Softwarenaut supports an extract-abstract-view workflow model}
\flabel{flow}
\end{center}
\end{figure}

Dedicated sections will treat each of the three steps of the workflow.




\newpage
% FACTS
\section {Fact Extraction}
\label{sec:facts}

The first step in architecture recovery is fact extraction. 

There are two types of facts that one can extract from the source code: artifacts, and relationships between them. 

Softwarenaut is built on top of FAMIX, a language independent object-oriented software meta-model...
FAMIX is a meta-model that supports the representation of systems written in object-oriented languages. Softwarenaut takes as input the model of a software system as it can be represented by FAMIX (specifically FAMIX 2.0). 


\subsection {Horizontal Relationships between Software Artefacts}

Depending on what are the extracted artefacts, and what is the language that is analyzed the dependnencies between artefacts can be of various types:

include relationships between files in C/C++
subclassing relationships between classes in all the Object Oriented languages
invocations between methods or functions in any programming language

The FAMIX model can model all these, and some more.


\subsection {Vertical Relationships between software artifacts}

Hierarchical organization is one of the most powerful tools for managing complexity. In software this means that in most of the cases, a software system is organized hierarchically: methods are grouped in classes, classes are grouped in modules, modules in systems. The relationships between artefacts that organize the system in a vertical hierarchy are called vertical relationships between the software artefacts. 

At the architectural level, various languages provide different mechanisms for the hierarchical organization of the system. In C/C++ the organization is given by the directory structure of the project, in Java by the package hierarchy, in Cincom Smalltalk by the bundles hierarchy, etc. In the cases where there is no hierarchy in place one can be automatically generated by performing hierarchical clustering on the artefacts in the system \cite{lungu-clust}. 



\newpage
% ORGANIZATION
\section {Information Aggregation}
\label{sec:org}

Aggregating horizontal relationships between software artefacts along vertical relationships is the fundamental technique that allows for abstraction in Softwarenaut. 

\fref{dep-agg} presents an example of how the low-level horizontal relationships between the methods of classes in a Java system are aggregated up along the hierarchical decomposition of the system. There are two explicit horizontal dependencies that are extracted from the system: the method calls between \cod{mc1} and respectively \cod{mc2} and \cod{mc5}. 
The explicit dependencies are propagated as implicit relationships vertically along the vertical relationships \cod{mc1 -- c1 -- B -- A}, \cod{mc5 -- c5 -- d -- c} and \cod{mc2 -- c2 -- d --c}. The highest level implicit relationship is the one between A and C. 


\begin{figure}[h]
\begin{center}
\includegraphics[width=0.6\linewidth]{images/DependencyAggregation}
\caption{The aggregation of explicit dependencies into implicit ones along the vertical relationships between methods, classes, and packages in a Java system}
\flabel{dep-agg}
\end{center}
\end{figure}

When a hierarchical decomposition is not provided, we can automatically generate one using clustering techniques. We presented elsewhere an experiment with clustering the classes in a system based on the similarity in the natural language terms that are used in their definitions \cite{Lung05a} and there is a rich literature on clustering software systems in general \cite{koschke-thesis}.

A data structure that allows for this is the Higraph introduced by Harel \cite{harel-visform}. In our case, the DPMHigraph\footnote{DPM stands for Detail Project Model} is a data structure formed by taking the graph of basic artefacts and horizontal relationships that exist between them and aggregating and propagating those relationships upwards along the hierarchical decomposition of the system. 

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.7\linewidth]{images/HigraphModel}
\caption{The DPMHigraph model is the core representation of a system in Softwarenaut}
%DPM stands for Detailed Project Model
\flabel{hmodel}
\end{center}
\end{figure}


The diagram from \fref{hmodel} presents two types of abstract entities and two types of abstract relations:
\begin{itemize}
\item Leaf Entities. The leaf entities are the basic object-oriented programming building blocks used for the structuring of software. Depending on the analyzed relation- ship, the leaf entities can be either methods or classes.
\item Composite Entities. The composite entities are containers for other entities. They can have direct mappings to programming language entities, such as classes, packages, namespaces or modules but can also represent abstract composites such as clusters.
\item Explicit Relationships. These are the relations between two entities. They are extracted from the code. The ones that we are interested in are method invocations, class inheritance and field access.
\item Implicit Relationships. The model admits relationships between any abstract entities. However, in software systems explicit relationships usually exist only be- tween the leaf entities. Therefore, the relations between the composite entities are inferred bottom-up from the relations existing between the leafs. The result is that between any two high-level components, we have a relation that represents a collection of all the relations between the leaf components aggregated in them.
\end{itemize}




% INTERACTION
\section {Interactive Exploration}
\label {sec:interact}

In this section we detail the interactive techniques that support the exploration process in Softwarenaut: 
navigation (\ref{sec:navi}), 
details-on-demand (\ref{sec:dod}),
rule-based filtering (\ref{sec:filtering}) and
first-class views (\ref{sec:views}).  

\subsection{Navigation}
\slab{navi}

The dominant exploration mechanism of Softwarenaut is navigation along the vertical decomposition of the system. One starts with a very high-level abstracted view of a system and continuously refines by using exploration operations \cite{robertson-conetrees}. At a given moment the set of visible nodes in the exploration view with which the user interacts constitutes the working set(WS). Initially the working set contains very few nodes and they are very high-level. As the user explores the system she transforms the working set by performing exploration operations on it and in this way, she changes the contents of the view in the exploration view.


\begin{figure}[b!]
\begin{center}
\includegraphics[width=\linewidth]{images/SnautSequence}
\caption{The expand and collapse complementary operations that allow vertical navigation in the Higraph}
\label{}
\end{center}
\end{figure}

The exploration operations supported by Softwarenaut are:

\begin{itemize}

\item Expand. By applying the expand operation to a node of the working set, the node is replaced in the working set with nodes representing its children. The operation can be defined as on operation on the working set (WS) in the following way:

\hspace{0.5cm} $ Expand_{N,HG} (WS) = WS - N + children (N, HG)$, 

where $children(x,h)$ is a function which returns the children of node $x$ in higraph $h$.

\item Collapse. By collapsing a node corresponding to a module, the node, together with all the nodes representing the siblings of the module are removed from the view and replaced with a node representing the parent module. Formally the operation is defined as follows:

\hspace{0.5cm} $ Collapse_{N,HG} (WS) = WS - N - siblings (N, HG) + parent (N, HG)$

where $siblings(x,h)$ is a function which returns the nodes that have the same parent with $x$ in higraph $h$, and $parent(x,h)$ is a function which returns the parent of node $x$ in higraph $h$. 

\item Filter.
By filtering a node, that node (and implicitly its children) will be removed from the working set. Formally the operation is defined as follows:

$ Filter_{N,HG} (WS) = WS - N$

\item Group.
By grouping several nodes together the user can reduce the clutter in the view. Formally the group operation is defined as follows: 

$ Group_{N_{i},HG} = WS - N_i + NewGroupNode $

where $N_i$ is the set of nodes that are to be removed from the working set.


\end{itemize}

As the user refines the view, and climbs down in the hierarchy of the system, more and more elements are brought into the view. In order to cope with the complexity of a graph with a large number of nodes and edges the user can use the Filter and group operations on explicit sets of nodes. One type of nodes that usually benefit from being filtered out are the  {\em omnipresent modules} - utility modules - that provide to many other modules in the system, contribute little to the understanding of the architecture of the system, and heavily clutter the view \cite{mitchell-bunch}.


% DOD
\newpage
\subsection {Details-on-Demand}
\slab{dod}


The elements of every architectural view in Softwarenaut are nodes that represent modules and edges that represent relationships between them. For the user to be confident that he {\em understands} such a view he needs to understand the role of every node and the meaning of every edge. Metaphorically, if the view were a phrase, the nodes would be the nouns and the edges would be the verbs. Only when one has understood all the nouns and the verbs he has really understood the story of the view.  

The Detail View panel of Softwarenaut is one of the ways in which one can understand the individual nodes and edges in an architectural view; it presents different detail views depending on the element that is currently selected in the exploration view. %There are therefore, two types of detail views: for nodes and for edges. 



\subsubsection {Detail Views for Modules}
They present details about the selected module. \fref{dnode} presents, as an example, the {\em Class Metrics} detail view, a view which presents all the classes that are contained in a certain module and metrics for them. The set of displayed metrics can be customized, and one can navigate to the code of the individual classes. 

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.43\linewidth]{images/DetailForNode.png}
\caption{This Class Metrics detail view shows the list of classes in the module named \cod{Model} from Softwarenaut. The classes are sorted based on their size as measured in lines of code.}

\flabel{dnode}
\end{center}
\end{figure}



\subsubsection {Detail Views for Relationships}
They present information about the selected relationships. Since understanding the relationships is critical for understanding the view Softwarenaut provides a broad set of detail views for relationships which cover both structural and evolutionary aspects of the relationships \cite{lungu-cutedge, lungu-relevo}. 

\fref{dedge} presents two such examples: to the left is the Invoked Artifacts view and to the right is the Interactive Methods view. 

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.9\linewidth]{images/DetailsForEdge}
\caption{Two example detail views for a relationship: (left) the Invoked Artifacts detail view; (right) the Interactive Methods detail view}
\flabel{dedge}
\end{center}
\end{figure}
The Invoked Artefacts view lists all the artefacts that are called by the selected high-level dependency. The tree has on its first levels the names of the classes that are invoked. The children of every class node are the individual methods that are invoked. The method nodes can be further expanded and the call sites can then be revealed. 

The Interactive Methods detail view presents the call graph of the method calls that are abstracted in the selected high-level dependency. 





\newpage
\subsection {Rule-Based Filtering}
\slab{filtering}

In the previous section we have introduced the Filter operation which works on explicit sets of nodes, and such a filter operation is offered by most software architecture recovery tools \cite{aracic-filtering}. However, Softwarenaut implements several categories of more advanced, {\em rule-based filters} that can be applied either on nodes or on edges:

\begin{itemize}
\item Metric-based filters. They filter entities and relationships based on their properties as captured by metrics. One example of this is filtering the weak dependencies or the very small modules in a view.
\item Type-based filters. Filtering entities or relations of a given type. One example of this is showing only inheritance relationships in a view.
\end{itemize}

Softwarenaut also implements several advanced filters that can be applied only on edges \cite{lungu-relevo}:

\begin{itemize}
\item Age-based filters are defined based on the historical evolution of an inter-module relationship in the system. They can only be applied when models for multiple versions of a system are loaded. %Fossil, Old, Lifetime, and Recent are four age-based filters that correspond to relationships which have the properties suggested by their names. In Figure XXY the first relationship is an old one, while the second is a new one. 

\item Dynamics-based filters are defined based on the dynamics of the relationship. Some relationships are stable across the versions while others are continuously changing. %Two such filters are Stable and Instable. In Figure XXY the first relatinoship is instable since all during the evolution of the system the types of relationships and their directions change while the second is stable.

\item Directional filters are defined based on the direction of the relationship between two modules. For example, filtering out the unidirectional relationships from an architectural view is useful for highlighting the modules that have mutual dependencies between themselves. 
\end{itemize}


Softwarenaut actually supports two types of filters: low-level filters and high-level filters.

\begin{itemize}

\item Low-level filters act on the higraph itself. They remove from the higraph the low-level elements that match a given condition. For example, all the invocation relationships that go to polymorphic classes.
%, will not remove the visual dependency between two modules if they contain other types of low-level dependencies.

\item High-level filters act on the high-level elements and relationships between them in the working set. For example, removing from the view all the high-level dependencies that abstract less few low-level dependencies.
\end{itemize}


\fref{filpan} presents the relation filtering panel as implemented in Softwarenaut. Several filters can be combined to obtain more powerful ones. During the exploration, the user generates many views. If a filter is active, each time a new view is generated, only those dependencies that the filter allows to be visible are visible.


\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{images/SnautFilteringPanel}
\caption{The UI for applying relationship filters in Softwarenaut}
\flabel{filpan}
\end{center}
\end{figure}


Rule-based relationships are a powerful way of reducing information in the view. The principle is simple: not all the relationships are equally relevant for the task at hand. When analyzing a system with a specific goal, the analysis will focus first on those relationships that are most relevant for the chosen goal. Two different goals are architecture recovery and architecture quality assessment: 

\begin{itemize}
\item When recovering the architecture of a system, the lifetime and old relationships are more relevant. They represent the architectural backbone of the system and their stability over time insures that it is worth analyzing them first.

\item When assessing the quality of an architecture, the recent relationships are of higher interest. Since they were recently introduced, they are more likely to be contrary to the original intended architecture. They might be the result of archi- tectural decay or of changes to the system performed by new developers that are unaware of the architecture. Continuously monitoring these relationships can be a good quality assurance policy.
\end{itemize}

\fref{lvr} presents two views on the same modules that are also present in \fref{filpan} but with age-based filters activated. 

\begin{itemize}
\item 
The left side presents only the Lifetime Relationships - 21 relationships that existed between the displayed modules in all the versions of the system. 
\item The right side presents only the Recent Relationships - 36 relationships that were introduced in the system in the latest version. 
\end{itemize}

Both the numbers are very low in comparison with the total number of relationships that are present in the last version of the system; both function as powerful filters.

\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{images/Architecture-LifetimeVsRecent}
\caption{The left part of the figure shows the Lifetime Relationships while the right part of the figure presents the Recent Relationships in Azureus/Vuze}
\flabel{lvr}
\end{center}
\end{figure}






\newpage
\subsection {First-Class Views}
\slab{views}

The designers of the system use multiple diagrams for the specification of the architecture of a system. Also the reverse engineers will need to recover multiple views when trying to understand the architecture of the system. Even if it was possible to present all the aspects of the architecture of a system in a single view, that view would overload the user with too much information.
%: by using multiple views each one can present an aspect of the system.

To avoid this cognitive overload, architecture recovery tools usually support some kind of semantic zooming \cite{storey-shrimp}. In our case we address this problem by directing the analysis towards the recovery of multiple architectural views. The technical detail that allows this is view persistence: in Softwarenaut one can save and restore any view during the exploration. This this allows for a {\em divide et impera} approach to architecture recovery and representation: each time a view risks becoming too complex it is saved and further exploration focuses only on a sub-part of the view. 

When a view is persisted, it is defined by six chunks of information:

\begin{enumerate}
\item The name of the system under analysis
\item The version of the system 
\item The current working set with the positions of all the nodes in it
\item The active node and edge filters, both explicit and rule based
\item The creator of the view
\item A name and a description of the view
\end{enumerate}

The model of the system is not saved and loaded together with the view since we assume that model construction is deterministic and the name and version of the system will be sufficient for reconstructing the model at a later time. Moreover, in most of the cases the views are reused locally.


%The filters are predefined. In the future we plan to support user-defined filters and their publication together with the views. 

\fref{viops} highlights the way the user can interact with the local views. He has a set of local views that he can save, load, delete locally. 


\newpage
% COLLABORATION
\section {Collaboration}
\label {sec:collab}

We have shown that in Softwarenaut views are entities that can be saved and restored. In this section we talk about the possibility of sharing the views with other users. 

Given that once published, a given version of a system never changes, it makes sense to publish all the analyses regarding that version, such that when other users analyze the same version or system they can benefit from the previous work. In the context of architectural view recovery this means discovering architectural views that others have already defined. To support sharing architectural information we have created a {\em Global Architectural View Repository} (GVR) which is a public repository that indexes architectural views \footnote{If privacy is a concern, view repositories can be created at the organization level}.

Softwarenaut is designed in such a way that, as soon as as soon as a user starts the analysis of a given system, it checks the available view repositories and retrieves the list of views that are already defined for that system and/or version.


\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{images/ViewOperations.pdf}
\caption{Views are first-class entities in Softwarenaut. They can be saved, deleted locally, but also published and retrieved from public or private repositories}
\flabel{viops}
\end{center}
\end{figure}

\fref{viops} presents the UI through which Sofwarenaut allows view operations. The top part of the inset presents the views which the user has locally. They can be loaded, deleted, or pushed to the GVR. The bottom part presents the views which exist for the given system in the GVR. From the global view repository he can pull views in the local repository, or if he is the creator of such a view he can delete it from the global repository too. The view sharing mechanism is the latest addition to Softwarenaut and we are still waiting to test it with users. 


\subsection {Softwarenaut Synergies}
One of the tools that benefits from the Global View Repository is the Small Project Observatory (SPO), an ecosystem analysis tool that we have introduced elsewhere \cite{lungu-est}. SPO works at an abstraction level above the architectural level of individual systems, the {\em ecosystem abstraction level} \cite{lungu-thesis}. 

\begin{figure}[th!]
\begin{center}
\includegraphics[width=0.7\linewidth]{images/SpoArchitectural}
\caption{The architectural views saved in Softwarenaut can be imported in SPO}
\label{}
\end{center}
\end{figure}
% This type of view is dynamic, it can not become obsolete...

% The main use case in which this navigation is needed is when one wants to understand a given system in the context of the ecosystem. 
In order to understand the ecosystem abstraction level SPO needs to support navigation between the two abstraction levels. When navigating from the ecosystem abstraction level down to the architectural level, SPO has to present architectural views of the individual systems. When they are available, the architectural views of the individual systems are obtained from the Global View Repository where they are published with Softwarenaut. In this way SPO can reuse information that was obtained by using Softwarenaut.

% In such a case SPO allows navigating down to the architectural level of the individual system, where it presents architectural views which are enriched with information from the ecosystem. 



\newpage
% DISC
\section {Discussion}
\label {sec:disc}

\subsection {Evaluating the Usability and Usefulness of the Tool}
We have tested Softwarenaut tool in two subsequent years with students in the Software Evolution master course at the University of Lugano. We organized a qualitative experiment: the students were asked to analyze a large software system that they have never seen before with the help of Softwarenaut and to produce an architectural report of the system as well as to fill some post-analysis forms. To make the assignment more interesting for them we grouped them in teams of two. 

Our goal in organizing the experiment was to test Softwarenaut and get feedback on both the usability of the tool and its usefulness for architecture recovery in the context of large software systems. We analyzed the reports ourselves and found them to be of various detail and quality. One observation that we made was that every group had come with a different perspective and set of different views on the system. We considered this to be an argument for supporting multiple views in architecture recovery. It might also be that ``{\em architecture is in the eye of the beholder}'' just as quality \cite{bass-architecture}.

By analyzing the post-experiment questionnaire we made several observations:

\begin{itemize}
\item Most of the students thought that the tool was easy to use and they thought that the reports they generated with it were reliable. 
\item The features that the students found most useful in their analysis were the details-on-demand views, and the predefined filters for both nodes and edges.
\item The features that the students thought were missing were: undo/redo facilities, parametrizable filters, arbitrary and rule-based grouping of elements\footnote{Since then we have implemented most of the features that the students requested.}
\end{itemize}

In the future we would like to empirically validate the usefulness of collaboration in architecture recovery and its implementation in the GVR.


\subsection {Integration with the Moose Analysis Platform}
Softwarenaut was developed on top of the Moose Analysis Platform \cite{nier-story}. The main feature that the tool uses from Moose is the FAMIX Core meta-model for representing object-oriented systems. The fact that Softwarenaut relies on the FAMIX Core meta-model allows it to be independent of the programming language: as long as there is a fact-extractor from a given language, systems written in that language can be imported and analyzed. 

Softwarenaut also uses several of the views defined in Moose, like for example some of the views that present entity metrics. Also, since behind any visual element of Softwarenaut lays a HiNode and behind it there is a FAMIX entity one can spawn other Moose analyses by selecting any of the elements of a Softwarenaut architectural view. 



\subsection {Beyond Architecture Recovery(I): Reengineering}
One of the tools that was built on top of Softwarenaut is MARS: an automated architecture refactoring recommender tool \cite{}. The tool starts from a given Softwarenaut view and tries to see whether move operations applied on classes can improve the architecture of the system by increasing coupling and decreasing cohesion. The preliminary results we obtained until show a good recall but a low precision of our automated refactoring recommendations. We plan to further study this phenomenon.

\subsection {Beyond Architecture Recovery (II): Monitoring Software Evolution}
Once a set of architectural views is recovered with Softwarenaut these views can be used for monitoring the evolution of the system. Indeed the Softwarenaut views are not static but instead they present relationships between the components in a given version. If desired, the views can be used as a basis for monitoring the evolution of the system, and integrated into the continuous development of the system. As soon as a new version is rolled out the differences between the architecture of the two versions can be highlighted on the saved views. Exploring ways in which the recovered views can be used as a live documentation of the evolution of the system is one of our future projects.



\newpage
% REL
\section {Related Work}
\label {sec:rel}

Pollet et al. have presented a comprehensive overview of the work in architecture recovery \cite{pollet-sar}. In this section we take several of the core aspects of Softwarenaut and we discuss how they are similar and how they differ from other state of the art tools.

\subsection {Exploration and Navigation.} Automatically aggregating the low-level relations, and then letting the user navigate from the highest abstraction level downwards is the main interaction approach in Softwarenaut. This is the exact opposite of the approach that M{\"u}ller proposed with Rigi \cite{muller-revengenv}. In their case, the user starts from the lowest-level facts and aggregates them as he climbs up in the abstraction hierarchy. Their approach does not scale when analyzing very large systems because the number of low-level artifacts is too large. Storey took the same top-down navigation approach in her work on SHriMP \cite{storey-shrimp}.

\subsection {Filtering.} Most of the architecture recovery tools support filtering \cite{aracic-filtering}. The majority of the tools allow for the explicit filtering of individual relations. As far as we are aware we are the only ones to propose filters based on evolutionary aspects of the relationships in the context of software exploration. However, there are two works that are somehow related. The first is Wierda et al. who recover the architectural decomposition of a system through clustering and observe that if they use for clustering only those dependencies that were in the system in both the first and the last versions, the decompositions are more precise \cite{wierda-clustering}; this observation supports our approach of using the lifetime relationships as more architecturally relevant than the other relationships. The second is Abram Hindle et al. \cite{hindle-yarn} who introduce the YARN visualization prototype which animates the evolution of dependencies between the modules of a system. The main difference between our approach and theirs is that we work on a snapshot-based model and they work on a commit-based model. Their commit-based model is advantageous since they benefit from more detailed information about the system but disadvantageous because an animation of all the commits is time consuming and does not support a query mechanism for visualizing only special types of relations.


\subsection {First-Class Views and Collaboration.} The work of Storey et al. on Shrimp also allows for saving and restoring views \cite{rayside-flow}. The views are saved inside a “Filmstrip” and then the filmstrip can be persisted and restored from the disk. Through the intermediation of the filmstrips the users can restore exploration sessions or even share certain views. This type of information allows people that know about each other to share information by emailing the files. The advantage of the Global View Repository is that it allows for discovering information that other users have discovered and about which the analysis is not aware. 
%(http://www.thechiselgroup.org/shrimp_manual_filmstrip)


Relevant for the collaborative reverse engineering part of our work is the Churrasco work of D’Ambros et al. \cite{dambros-churrasco}. Churrasco supports software evolution modeling, visualization and analysis through a web interface. 
Through an example scenario they show that Churrasco allows for collaborative software evolution analysis, based on the fact that the visualizations are available on the web. The collaboration happens by annotating the various elements in the views of Churrasco. However, their tool presents a set of predefined views and they are not that much architectural views but rather design-level views. 

One project which was started with collaboration support as the main goal is the Jazz IDE of IBM \cite{hupfer-jazz}. The goal of the Jazz ``collaborative development environment'' is to enhance and enrich collaboration in small, informal software development teams. Jazz has several features to support awareness of team member activities in addition to screen sharing such as local history of chats that are anchored in the code providing therefore context to the discussions. The main difference between their work and ours is the goal of the project.





\newpage
% CONC
\section {Conclusions and Future Work}
\label {sec:conc}

In this article we have presented Softwarenaut, our tool which is state of the art in architecture recovery. The tool allows the recovery of architectural views of a software system and supports collaboration and integration with other tools. 


\subsection* {Installation and Documentation}
Softwarenaut is released under the MIT licence and is available online at http://lungu.org/mircea/softwarenaut. On the homepage of the tool there are a set of screencasts that present its various features. 

\subsection* {Acknowledgements} We are grateful to ... for ...


\newpage

%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}

%% References
%%
%% Following citation commands can be used in the body text:
%% Usage of \cite is as follows:
%%   \cite{key}          ==>>  [#]
%%   \cite[chap. 2]{key} ==>>  [#, chap. 2]
%%   \citet{key}         ==>>  Author [#]

%% References with bibTeX database:

\bibliographystyle{model1-num-names}
\bibliography{scg,thesis}

%% Authors are advised to submit their bibtex database files. They are
%% requested to list a bibtex style file in the manuscript if they do
%% not want to use model1-num-names.bst.

%% References without bibTeX database:

% \begin{thebibliography}{00}

%% \bibitem must have the following form:
%%   \bibitem{key}...
%%

% \bibitem{}

% \end{thebibliography}


\end{document}

%%
%% End of file `elsarticle-template-1-num.tex'.
